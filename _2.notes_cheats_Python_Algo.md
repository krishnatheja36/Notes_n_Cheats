# Python notes and Cheats

## 1. Documentation
``` python
python -m pydoc open or help(open) in the python shell
dir(), dir(object), type(a) #type() tells what an object is; dir() tells what you can do with or what is contained within an object.
Comments -'#' or '"""' is used too
```
## 2. Imports:
```python
from sys import argv
import os
import configargparse								# Modern
import argparse, configparser
from collections import Counter, defaultdict, deque
from queue import PriorityQueue
from itertools import combinations, permutations, groupby
import re
import math
import datetime
import pandas as pd
import json
from multipledispatch import dispatch
from functools import reduce
import heapq
import array as arr
import numpy as np
import random
```

## 3. Data typers, Operators and Functions:
```python
Strings -> are immutable
Tuple	-> a = ('physics', 'chemistry', 1997, 2000) immutable, del tup; elements cannot be sorted
Arrays	-> Need to be declared, Fixed, Homogeneous (stores elements of a single type), Optimized for numerical operations,
Sets	-> The sets are an unordered collection of data types. These are mutable, iterable, and do not consist of any duplicate elements.
```			
## 4. Numeric
```python
num digit = divmod(number, 10), // - floor, ** - Exponential # +, -, *, % -> basic
```

## 5. Strings/Arrays/Lists
```python
str() vs chr() vs ord() #chr() chr(65)-> 'A', chr(97)-> 'a' chr(columnNumber % 26 + 65) ord('A') -> 65
.isalnum(), .isalpha(), .isnumeric(), isdigit(), .count('t')
.upper(), .lower(), title(), .split(), ''.join([]), .sort(), .reverse(), sorted()
len(s), .strip(), .ltrip(), .rstip(), .capitalize(), .replace('old', 'new'), s[::-1] #reverse 
find(-1 if not found), index(value error, if not found), rfind, rindex 
```

## 6. Sets
```python
add(), pop(), update(), intersection(), .discard()
DaysA|DaysB, DaysA & DaysB, DaysA - DaysB 	#union of sets, #intersection, #Difference
```

## 7. Dictionairies
```python
get('key','default'), .clear()
collections.ChainMap(dict1, dict2)
```

## 8. Counter
```python
Counter(list), .keys(), .values(), .get('B'), .most_common() 
```

## 9. Functions
```python
def function_name(arg1, arg2 or *args) #functions vs method, every method is a function. Method created in a class and called by an object. Function not so, just called by name.   
```

## 10. File handling
```python
with open('filename.txt', 'mode') as f: 
	f.read(), f.readline(), f.readlines(), f.write("stuff"), f.truncate(), f.truncate(10), os.truncate(path, 10) # truncates to 10 bytes
```

## 11. Lambda functions
```python
lambda arguments : expression
s2 = lambda func: func.upper()												# print(s2("TestThisString"))
n = lambda x: "Positive" if x > 0 else "Negative" if x < 0 else "Zero"		# print(n(-5))
li = [lambda arg=x: arg * 10 for x in range(1, 5)] 							# for i in li: print(i())
sq = lambda x: x ** 2														# print(sq(3))
sq = lambda x: x ** (1/2)													# print(sq(16))
calc = lambda x, y: (x + y, x * y)											# print(calc(3, 4))
even = filter(lambda x: x % 2 == 0, n) or list(filter(lambda x: x%2 ==0, n))# n = [1, 2, 3, 4, 5, 6] print(list(even)) 
b = list(map(lambda x: x*2, n))												# n = [1, 2, 3, 4, 5, 6] print(b)
new_dict = dict(map(lambda item: (item[0], item[1]**2), my_dict.items()))	# my_dict = {'a': 1, 'b': 2, 'c': 3} print(new_dict)
s = reduce(lambda x, y: x + y, n)											# n = [1, 2, 3, 4, 5, 6] print(s) 			#from functools import reduce
p = reduce(lambda x, y: x * y, n)											# n = [1, 2, 3, 4, 5, 6] print(p)	
```

## 12. Queues
```python
queue = deque(), queue.append(timestamp), queue.appendleft(timesytamp), queue.pop(), queue.popleft() 		# double sided queue # lib->collections
pq = PriorityQueue(), pq.put((1, 'object1')), pq.put((2, 'object2')), pq.put((1, 'object3')) and pq.get()	# lib->queue
directly access internal list of pq -> print(pq.queue)

heapq.heapify(list) #By default this implements min heap. Multiply variables with -1 and add to implement max heap
heapq.heappop(minheap), heapq.heappush(self.minheap, val), minheap[0], minheap[-1] #min element, max element
```

## 13. One line list creations
```python
info = ["{}={}".format(k,v) for k,v in params.items()]
[dict.setdefault(l, 0) for l in range(len(weights[i]))]
```

## 14. Misc functions
```python
random.randint(1,300)
os.getcwd()
min(list) or min(list, key=len), 
min(data, key=lambda person: person["age"]) #data = [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}, {"name": "Charlie", "age": 35}]
max(def_dict.keys(), key=def_dict.get)

list.sort(key=len, reverse=True) or sorted(list, key=len, reverse=True) 	# my_list = ["apple", "banana", "kiwi", "grapefruit"]
sorted(map(str, list), key=len, reverse=True)								# n = [1, 2, 3, 4, 5, 62]
sorted(my_dict, key=my_dict.get, reverse=True)							# my_dict = {'apple': 5, 'banana': 2, 'cherry': 8}
sorted(my_dict.items(), key=lambda x:x[1], reverse=True)					# 
res_lst = sorted(map(sorted, combinations(x,2)))

for i, node in enumerate(nodes): or for i, node in enumerate(nodes, 1): # to start from 1
for nums, target in zip(nums_lists,target_list):
for key, group in groupby(data, key=lambda x: x[0]):          # data = [('A', 1), ('A', 2), ('B', 3), ('B', 4), ('C', 5)] 
    print(f"Key: {key}, Group: {list(group)}") 	              # -> data.sort(key=lambda x: x[0])  # Data must be sorted # lib-> itertools 

json_str = json.dumps({'a':{'b':'c', 'd':'e'}})
json_obj = json.loads(json_str)
```
## 15. Abstract class
``` python
from abc import ABC, abstractmethod
class Animal(ABC):						# This will raise an error - can't instantiate abstract class
    @abstractmethod						# animal = Animal()
    def make_sound(self):
        pass
    @abstractmethod
    def move(self):
        pass
    def sleep(self):  # Regular method (not abstract)
        print("Sleeping...")

class Dog(Animal):
    def make_sound(self):
        print("Woof!")

    def move(self):
        print("Running on four legs")

dog = Dog()
dog.make_sound()  # Woof!
dog.sleep()  # Sleeping...
```

## 16. Decorator
```python

1.	def my_decorator(func):
		def wrapper():
			print("Before function")
			func()
			print("After function")
		return wrapper

	@my_decorator
	def say_hello():
		print("Hello!")

	say_hello()
	# Output:
	# Before function
	# Hello!
	# After function

2.	import time

	def timing_decorator(func):
		def wrapper(*args, **kwargs):
			start = time.time()
			result = func(*args, **kwargs)
			end = time.time()
			print(f"{func.__name__} took {end - start:.4f} seconds")
			return result
		return wrapper

	@timing_decorator
	def slow_function():
		time.sleep(1)
		return "Done"

	slow_function()  # slow_function took 1.0012 seconds

```

## Complexities:
```python
Time and Space
	Sorting the array takes O(nlogn)\mathcal{O}(n\log{n})O(nlogn), O(logn) to O(n)\mathcal{O}(n)O(n)
	
	QuickSort
		Time - O(nlogn)
	CyclicSort
		Time - O(n^2)
		
	Binary Search
		Time - O(logn)
		Space
			Iterative - O(1)
			Recursive - O(logn) - Every time a recursive call takes place all local variables are pushed to the stack (stack size increases)
```

## Identify Patterns
### 1. Two Pointers
	- Linear data structure: 
		The input data can be traversed in a linear fashion, such as an array, linked list, or string.
	- Process pairs: 
		Process data elements at two different positions simultaneously.
	- Dynamic pointer movement: 
		Both pointers move independently of each other according to certain conditions or criteria. In addition, both pointers might move along the same or two different data structures.
### 2. Fast and Slow Pointers
	- Linear data structure: 
		The input data can be traversed in a linear fashion, such as an array, linked list, or string.
	In addition, if either of these conditions is fulfilled:
	- Cycle or intersection detection: 
		The problem involves detecting a loop within a linked list or an array or involves finding an intersection between two linked lists or arrays.
	- Find the starting element of the second quantile: 
		This means identifying the element where the second part of a divided dataset begins—like the second half, second third (tertile), or second quarter (quartile). 
		For example, the task might ask you to find the middle element of an array or a linked list, which marks the start of the second half.
### 3. Sliding Window
	- Contiguous data: 
		The input data is stored in a contiguous manner, such as an array or string.
	- Processing subsets of elements: 
		The problem requires repeated computations on a contiguous subset of data elements (a subarray or a substring), such that the window moves across the input array from one end to the other. 
		The size of the window may be fixed or variable, depending on the requirements of the problem.
	- Efficient computation time complexity: 
		The computations performed every time the window moves take constant or very small time.
### 4. Merge Intervals
	- Array of intervals: 
		The input data is an array of intervals.
	- Overlapping intervals: 
		The problem requires dealing with overlapping intervals, either to find their union, their intersection, or the gaps between them.
### 5. In-Place Manipulation of a Linked List
	- Linked list restructuring: 
		The input data is given as a linked list, and the task is to modify its structure without modifying the data of the individual nodes.
	- In-place modification: 
		The modifications to the linked list must be made in place, that is, we’re not allowed to use more than O(1) additional space.
### 6. Heaps
	- Linear data: 
		If the input data is linear, it can be sorted or unsorted. I
		- A heap efficiently finds the maximum or minimum elements if the data is unsorted. Operations like insertion and deletion take O(logn) time, ensuring fast access to the top elements.
		- If the data is sorted, a heap can still be useful when frequent insertions and deletions are required, as it allows for efficient updates and retrieval of the highest or lowest elements, 
		with both insertion and deletion operations also taking O(logn) time.
	- Stream of data: 
		The input data continuously arrives in real time, often in an unpredictable order, requiring efficient handling and processing as it flows in. Heaps automatically enforce priority ordering 
		(e.g., largest weight, smallest cost, highest frequency). This saves you from manually resorting to or scanning each time your data changes.
	- Calculation of maxima and minima: 
		The input data can be categorized into two parts, and we need to repeatedly calculate two maxima, two minima, or one maximum and one minimum from each set.
	- Efficient retrieval of extreme values: 
		The solution needs to retrieve or update the min or max element repeatedly but cannot afford a full sort each time; a heap-based priority queue offers O(logn)insertion/removal and O(1) retrieval.
	- Custom priority-based selection: 
		The problem involves selecting the next element based on specific priority at each step, such as processing the largest task or earliest event.
### 7. K-way merge
	- Involves merging sorted arrays or a matrix: 
		The problem involves a collection of sorted arrays or a matrix with rows or columns sorted in a specific order that needs to be merged. This could be the core of the problem or a step toward 
		the solution.
	- Seeking the kth smallest/largest across sorted collections: 
		The problem involves identifying the kth smallest or largest element across multiple sorted arrays or linked lists.
### 8. Top K Elements
	Yes, if both of these conditions are fulfilled:
	- Unsorted list analysis: 
		We need to extract a specific subset of elements based on their size (largest or smallest), frequency (most or least frequent), or other similar criteria from an unsorted list. 
		This may be the requirement of the final solution, or it may be necessary as an intermediate step toward the final solution.
	- Identifying a specific subset: 
		The goal is to identify a subset rather than just a single extreme value. When phrases like top k, kth largest/smallest, k most frequent, k closest, or k highest/lowest describe our task, 
		it suggests the top k elements pattern is ideal for efficiently identifying a specific subset.
	No, if any of these conditions is fulfilled:
	- Presorted input: 
		The input data is already sorted according to the criteria relevant to solving the problem.
	- Single extreme value: 
		If only 1 extreme value (either the maximum or minimum) is required, that is, k=1, as that problem can be solved in O(n) with a simple linear scan through the input data.
### 9. Modified Binary Search
	Yes, if either of these conditions is fulfilled:
	- Target value in sorted data: 
		The problem involves locating a specific target value—or identifying its first or last occurrence—within a sorted array or list. This pattern applies to data structures that support 
		direct addressing.
	- Partially sorted segments: 
		We may use this pattern when segments of an input array are sorted.
	No, if either of these conditions is fulfilled:
	- Lack of direct addressing: 
		The input data structure does not support direct addressing.
	- Unsorted or inappropriately sorted data: 
		The data to search is not sorted according to criteria relevant to the search. For example, if we’re looking for a particular date in a list of dates, but the list is sorted in 
		alphabetical order (and not chronologically), we cannot use binary search.
	- Non-value-based solutions: 
		The problem does not require identifying a specific value or range of values. For example, if we have a list of student names only and we want to search for a student, 
		modified binary search won’t be a correct choice.
### 10. Subsets
	- Requirement for combinations or subsets: 
		The problem asks us to generate combinations (or subsets) of the elements from the input data structure. This could be the final solution itself or a step toward reaching the solution.
### 11. Greedy Techniques
	Yes, if both of these conditions are fulfilled:
	- Optimization problem: 
		The problem is an optimization problem, where we are looking to find the best solution under a given set of constraints. This could involve minimizing or maximizing some value, 
		such as cost, distance, time, or profit.
	- Making local choices leads to a global solution: 
		The problem can be solved by making simple decisions based on the current option or state without needing to look ahead or consider many future possibilities.
	No, if any of these conditions is fulfilled:
	- Local choices lead to sub-optimal solutions: 
		Our analysis shows that making local greedy choices leads us to a sub-optimal solution.
	- Problem lacks clear local optima: 
		If the problem doesn’t naturally break down into a series of choices where we can identify the best option at each step, a greedy algorithm might not be applicable.
### 12. Backtracking
	Yes, if any of these conditions is fulfilled:
	-> Complete exploration is needed for any feasible solution: 
		The problem requires considering every possible choice to find any feasible solution.
	-> Selecting the best feasible solution: 
		When the goal is not just to find any feasible solution but to find the best one among all feasible solutions.
	No, if the following condition is fulfilled:
	-> Solution invalidity disqualifies other choices: 
		In problems where failing to meet specific conditions instantly rules out all other options, backtracking might not add value.
### 13. Dynamic Programming
	- Overlapping subproblems: 	
		We encounter overlapping subproblems, that is, we can use the results of one subproblem when solving another, possibly larger subproblem.
	- Optimal substructure: 
		In problems where the final solution can be constructed from the optimal solutions to its subproblems.
### 14. Cyclic Sort
	Yes, if either of these conditions are fulfilled:
	- Limited range integer arrays: 
		The problem involves an input array of integers in a small range, usually [1−n].
	- Finding missing or duplicate elements: 
		The problem requires us to identify missing or duplicate elements in an array.
	No, if any of these conditions is fulfilled:
	- Noninteger values: 
		The input array contains noninteger values.
	- Nonarray format: 
		The input data is not originally in an array, nor can it be mapped to an array.
	- Stability requirement: 
		The problem requires stable sorting.
### 15. Topological Sort
	Yes, if either of these conditions is fulfilled:
	- Dependency relationships: 
		The problem involves tasks, jobs, courses, or elements with dependencies between them. These dependencies create a partial order, 
		and topological sorting can be used to establish a total order based on these dependencies.
	- Ordering or sequencing: 
		The problem requires determining a valid order or sequence to perform tasks, jobs, or activities, considering their dependencies or prerequisites.
	No, if either of these conditions is fulfilled:
	- Presence of cycles: 
		If the problem involves a graph with cycles, topological sorting cannot be applied because there is no valid linear ordering of vertices that respects the cyclic dependencies.
	- Dynamic dependencies: 
		If the dependencies between elements change dynamically during the execution of the algorithm, topological sorting may not be suitable. 
		Topological sorting assumes static dependencies that are known beforehand.
### 16. Sort and Search
	- Sortable data: 
		The input data can be sorted before applying search techniques (e.g., arrays or lists of numbers).  Sorting the input makes relationships between elements clearer or can simplify operations.
	- Pairwise and ordered comparisons: 
		The problem involves comparing pairs or subsets of data elements to identify specific relationships or conditions, where these comparisons depend on the relative order of the elements.
	- Range-based values: 
		The task involves identifying or processing elements within a specific range or threshold.
	- Optimization based on relationships:  
		The problem requires optimizing a solution by evaluating how data elements relate, such as finding maximum or minimum values or optimal distances between them.
	- Efficient searching methods: 
		If the problem benefits from efficient searching methods like binary search, two-pointer traversal, sliding window, etc., to reduce the complexity of exploring potential solutions.
### 17. Matrices
	- 2D array input: 
		The input data is given as a 2D array. However, some exceptions to this could be problems that have a 2D array as an input, but are solved with some other pattern, 
		e.g., graphs, dynamic programming etc.
### 18. Stacks
	Yes, if either of these conditions is fulfilled:
	- Reverse order processing: 
		The problem involves processing elements in reverse order or requires the last element added to be processed first.
	- Nested structures handling: 
		The problem involves nested structures, like parentheses, brackets, or nested function calls.
	- State tracking: 
		The problem requires keeping track of previous states or undoing operations.
	- Expression evaluation: 
		The problem involves evaluating expressions.
	No, if either of these conditions is fulfilled:
	- Order dependence: 
		The problem requires either a different order dependence than Last In, First Out (LIFO) or there is no order dependency at all.
	- Random access: 
		The problem involved frequent access or modification of elements at arbitrary positions is needed and not just from the end.
	- Need for searching: 
		The problem requires efficient searching for elements based on values or properties.
### 19. Graphs
	Relationships between elements: 
		There is a network of interconnected objects with some relationship between them; that is, the data can be represented as a graph.
### 20. Tree Depth-First Search
	- Tree data structure: 
		The input data is in the form of a tree, or the cost of transforming it into a tree is low.
	- Balanced/low branching factor: 
		The tree is balanced or has a low branching factor, where DFS provides efficient exploration due to less recursion or backtracking.
	- Hierarchical structures: 
		We deal with hierarchical structures like organizational charts or family trees, where traversing from parent to child nodes or vice versa is essential for problem-solving.
	- Solution near the leaves: 
		We have reason to believe that the solution is near the leaves of the tree. Instead, if the problem requires exploring all nodes at the same depth before moving to the next level. 
		This can be done more optimally by the breadth-first search (BFS) algorithm.
	- Traversal along paths: 
		Components of the solution are listed along paths from the root to the leaves, and finding the optimal solution requires traversal along these paths. 
		A classic example of this is finding the height of a given tree.
	- Explore all possible paths: 
		The problem requires exploring all possible paths in the tree to find a solution or enumerate all valid solutions. Instead, if finding the shortest or optimal path is crucial, 
		especially in scenarios like route planning or maze solving, BFS might provide a more suitable approach.
### 21. Tree Breadth-First Search
	- Tree data structure: 
		The input data is in the form of a tree, or the cost of transforming it into a tree is low.
	- Not a wide tree: 
		If the tree being searched is very wide. In such scenarios, the time complexity of breadth-first search may become prohibitive.
	- Level-by-level traversal: 
		The solution dictates traversing the tree one level at a time, for example, to find the level order traversal of the nodes of a tree or a variant of this ordering.
	- Solution near the root: 
		We have reason to believe that the solution is near the root of the tree. Instead, if the solution is near the leaves of the tree, 
		BFS may not be efficient because it exhaustively explores nodes level by level. In such cases, depth-first search (DFS) would be more suitable for traversing deep into the tree.
----
