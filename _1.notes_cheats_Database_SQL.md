# SQL Notes and Cheats
## 1. Analytical function
```sql
	- https://oracle-base.com/articles/misc/analytic-functions
	- AVG(sal) OVER (PARTITION BY deptno) AS avg_dept_sal
	- AVG(sal) OVER (PARTITION BY deptno ORDER BY sal) AS avg_dept_sal_sofar
	- AVG(sal) OVER (PARTITION BY deptno ORDER BY sal RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS range_avg  	-- Same as above, generate average by the value 
    - AVG(sal) OVER (PARTITION BY deptno ORDER BY sal ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS rows_avg		-- It will generate avg by row
 	- FIRST_VALUE(sal IGNORE NULLS) OVER (PARTITION BY deptno ORDER BY sal ASC NULLS LAST) AS first_val_in_dept
 	- FIRST_VALUE(sal) OVER (ORDER BY sal ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS previous_sal,
    - LAST_VALUE(sal) OVER (ORDER BY sal ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS next_sal
    - rank() over (partition by deptno order by sal) as myrank
    - dense_rank() over (partition by deptno order by sal) as myrank 	- consecutive ranks
    - rank(2000) within group (order by sal) as row_rank		-- Aggregator function
    - dense_rank(2000) within group (order by sal) as row_rank	-- Aggregator function
    - ROW_NUMBER() OVER (ORDER BY val DESC) AS val_row_number
    - PERCENT_RANK() OVER (ORDER BY val) AS val_percent_rank
    - NTILE(3) OVER (ORDER BY val) AS val_ntile 
    - LAG(sal, 1, 0) OVER (ORDER BY sal) AS sal_prev
    - LEAD(sal, 1, 0) OVER (ORDER BY sal) AS sal_next,
	- WHERE  rownum <= 5
```
## 2. Decode
```sql
	- DECODE(supplier_id, 
					10000, 'IBM',
                    10001, 'Microsoft',
                    10002, 'Hewlett Packard',
                    'Gateway') result
	- DECODE((date1 - date2) - ABS(date1 - date2), 0, date1, date2) - date1 is greater
```
## 3. Case
```sql
	- CASE 
		WHEN t.status in ('cancelled_by_driver','cancelled_by_client') 
			THEN 1 
			ELSE 0 
	  END
	- CASE category_id
    	WHEN 1 THEN ROUND(list_price * 0.05,2) 	-- CPU
    	WHEN 2 THEN ROUND(List_price * 0.1,2)  	-- Video Card
    	ELSE ROUND(list_price * 0.08,2) 		-- other categories
  	  END discount
```
## 4. String/date/Number
```sql
	- ROUND(number, decimal_places) and ROUND(date [, format])
		- SELECT ROUND(123.456) FROM dual;
		- SELECT ROUND(123.456, 2) FROM dual;
		- SELECT ROUND(12345.67, -2) FROM dual;
		- SELECT ROUND(2.5) FROM dual;			-- Result: 3
		- SELECT ROUND(DATE '2024-02-20', 'MONTH') FROM dual;  -- Result: 01-MAR-2024 (20th is past the 15th midpoint)
		- SELECT ROUND(TIMESTAMP '2024-02-05 14:30:00') FROM dual; 	-- Result: 05-FEB-2024 (rounds up after noon)
	- trunc() -- (no rounding)
		- SELECT TRUNC(123.789, 2) FROM dual; 	-- Result: 123.78
		- SELECT TRUNC(DATE '2024-02-20', 'MONTH') FROM dual;	-- Result: 01-FEB-2024
	- trim() LTRIM() RTRIM()
		- SELECT TRIM('  Hello World  ') FROM DUAL;
		- SELECT TRIM(LEADING '0' FROM '00012345') FROM DUAL;
		- SELECT TRIM(TRAILING 'x' FROM 'Testxx') FROM DUAL;
		- SELECT TRIM(BOTH 'a' FROM 'abracadabra') FROM DUAL;
		- SELECT TRIM('a' FROM 'abracadabra') FROM DUAL;
		- SELECT LTRIM('  hello  ') FROM dual;
		- SELECT LTRIM('xyxyhello', 'xy') FROM dual;
		- SELECT RTRIM('  hello  ') FROM dual;
		- SELECT RTRIM('helloxyxy', 'xy') FROM dual;
	- to_number() 
		- select to_number(trim(to_char(avg(c3.amount),'999D99'))) from dual
	- to_char() - '999D99', 'yyyy-mm-dd'
		- select to_char(visit_date,'yyyy-mm-dd') visit_date from dual
	- to_date()
	- substr()
		- SUBSTR('This is a test', 6, 2)
		- SUBSTR('TechOnTheNet', -5, 3)
		- SUBSTR('TechOnTheNet', 3)
		- SUBSTR('TechOnTheNet', -3)
	- TRANSLATE and REPLACE 
		- select replace(translate(name,'AEIOUeiou','aaaaaaaaa'),a,'')
	- instr()
		- INSTR( 'String', 'is', 1, 2 ) second_occurrence
		- INSTR( 'String', 'is', -1, 1 ) last_occurrence 
		- INSTR( string, substring [, start_position [, th_appearance ] ] )
	- lpad()
		- LPAD(amount, 12, '*'), RPAD(amount, 12, '*')
	
```
## 5. Null Handling in joins
```sql
	- COALESCE() vs NVL() -- Coalesce() requires the datatypes to be the same. 
```
## 6. Recursive CTE - 	curr
```sql
	
1.	WITH number_sequence (n) AS (
   		SELECT 1 FROM dual  
    	UNION ALL
    	SELECT n + 1
    	FROM number_sequence
    	WHERE n < 10
	)
	
2.	WITH employee_hierarchy (employee_id, employee_name, manager_id, level_num, path) AS (
    -- Anchor: Start with CEO (no manager)
    SELECT 
        employee_id,
        employee_name,
        manager_id,
        1 as level_num,
        employee_name as path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: Find employees of current level
    SELECT 
        e.employee_id,
        e.employee_name,
        e.manager_id,
        eh.level_num + 1,
        eh.path || ' > ' || e.employee_name
    FROM employees e
    INNER JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
	)
	
3.	WITH fibonacci (n, fib_curr, fib_next) AS (
    -- Anchor: F(0)=0, F(1)=1
    SELECT 
        1 as n,
        0 as fib_curr,
        1 as fib_next
    FROM dual
    
    UNION ALL
    
    -- Recursive: F(n) = F(n-1) + F(n-2)
    SELECT 
        n + 1,
        fib_next,
        fib_curr + fib_next
    FROM fibonacci
    WHERE n < 10
	)
	-- Call
	SELECT 
		n,
		fib_curr as fibonacci_number
	FROM fibonacci;

```	
## 7. MISC
```sql
	- select rownum id from all_objects where rownum <=20
```   
## 8. Query tuning
```sql
	Execution Plan
	- Row Estimates
	- I/O reads
	- Access Methods
	- Step Duration
	Explain Plan
	- DBMS_XPlan
```
## 9. Stored Procedure
```sql
	DECLARE
	BEGIN
		EXCEPTION
	END;
	/

	-- Variable				: 	variable_name [CONSTANT] datatype [NOT NULL] [:= | DEFAULT initial_value]
	-- Constant and Literal	:	constant_name CONSTANT datatype := VALUE;

	IF condition1
	THEN  
		//Block of statements1
	ELSIF condition2
		//Block of statements2
	ELSE  
		//Block of statements3
	END IF;

	CASE [expression]  
		WHEN condition1 THEN Block of statements1  
		WHEN condition2 THEN Block of statements2
		...  
		WHEN conditionn THEN Block of statementsn
		ELSE Block of statements  
	END CASE;

	WHILE condition
	LOOP
	//block of statements;
	END LOOP;
	
	FOR loop_counter IN [REVERSE] start_value .. end_value
	LOOP
	//block of statements.
	END LOOP;

	continue and EXIT

	<< label >>

	GOTO label_name;  
	//Other statements  
	<<label_name>>  
	Statement;

	-- Stored Procedure
	CREATE [OR REPLACE] PROCEDURE proc_name [list of parameters] 
	IS | AS    
	//Declaration block 
	BEGIN    
	//Execution block 
	EXCEPTION    
	//Exception block 
	END;

	EXEC procedure_name();
	or
	BEGIN
	procedure_name;
	END;
	/

	CREATE [OR REPLACE] FUNCTION function_name [parameters] 
	RETURN return_datatype;  
	IS|AS
		//Declaration block
	BEGIN  
		//Execution_block 
		Return return_variable;  
	EXCEPTION  
		//Exception block  
		Return return_variable;  
	END; 
	/
```
